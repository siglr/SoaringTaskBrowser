"use strict"

// ********************************************************************************************
// *********  Manager for the airports data                ************************************
//
// Loaded from AIRPORTS_JSON_URL (in this repo as airports/airports.json)
// Note each 'airport' entry in the JSON is a LIST, so the downloaded JSON is more compact
// so the JSON includes an "airport_keys" dictionary that maps property_name -> index.
// e.g. Mifflin County is:
// ['KRVL', 40.6773872375488, -77.6268310546875, 'Mifflin Co', 'msfs_airport', 247.80239207032346, '06 24']
// and airports_data.airports_keys is:
// "airport_keys": {"ident": 0, "lat": 1, "lng": 2, "name": 3, "type": 4, "alt_m": 5, "runways": 6}
// Note the "airport_keys" data is generated by the program that creates the airports data, and we
// may add additional properties, so the key indexes could change.
//
// Downloaded airports_data is:
// {
//      "airport_keys": KEY -> INDEX dictionary for airport properties (as above)
//      "box_coords":   BOX_ID -> BOX COORDINATES dictionary for each 'box' of airports
//      "boxes": BOX_ID -> list of airports (& each airport is a list of property values)
// }
//
// The whole point of this airports_data structure is to support fast lookup of airports within
// a given lat/lng box (i.e. the map bounds).
//
// ********************************************************************************************

/*
This class is usable in B21 Task Planner and B21LeafletMap used in MSFS Nav instruments, with the parent object
given in the constructor as "mapper". The mapper interface required is:

mapper.airport_markers = Leaflet layerGroup e.g. L.layerGroup().addTo(parent.map);
mapper.canvas_renderer = L.canvas()
mapper.task.add_new_poi(position, type, info) -- only used for planner, i.e. is_instrument() == false
*/

class B21_Airports {

    constructor(mapper, options) {
        this.AIRPORTS_JSON_URL = options["json_url"];
        this.AIRPORT_IMG_URL = options["airport_img_url"];

        this.DEBUG_DRAW_MAP_BOXES = false;

        this.mapper = mapper;
        this.airports_data = null;
        this.markers = null; // dictionary IDENT -> marker for each airport drawn on map
        this.search_ident = null; // ident of an airport search result to be highlighted on map

        new LeafletCanvasMarker(); // Extend leaflet so we can add markers to the canvas

        this.available = false;
    }

    // init() will asynchronously download the airports data
    init(map) {
        fetch(this.AIRPORTS_JSON_URL).then(response => {
            if (!response.ok) {
                alert("Failed to download the airports data")
                return null;
            }
            //response.headers.set('content-type','application/json');
            return response.text();
        }).then(results => {
            console.log("airports.json loaded");
            this.airports_data = JSON.parse(results);
            this.KEY_LAT = this.airports_data.airport_keys['lat'];
            this.KEY_LNG = this.airports_data.airport_keys['lng'];
            this.KEY_NAME = this.airports_data.airport_keys['name'];
            this.KEY_IDENT = this.airports_data.airport_keys['ident'];
            this.KEY_TYPE = this.airports_data.airport_keys['type']; //"closed_airport", "heliport", "large_airport", "medium_airport", "seaplane_base", "small_airport", "msfs_airport"
            this.KEY_ALT_M = this.airports_data.airport_keys['alt_m'];
            this.KEY_RUNWAYS = this.airports_data.airport_keys['runways'];
            this.available = true;
            this.draw(map);
        }).catch(error => {
            console.error('Network error accessing airports.json:', error);
        });
    }

    draw(map) {
        const ZOOM_MIN_MSFS = 8;
        const ZOOM_MIN_OTHER = 9;

        this.mapper.airport_markers.clearLayers();

        if (!this.available) {
            console.log("b21_airports.draw(), airports not available, returning.");
            return;
        }

        this.markers = {};

        let zoom = map.getZoom();
        if (zoom < ZOOM_MIN_MSFS) {
            console.log("Too zoomed out to display airports");
            return;
        }
        //console.log("airports.draw(map) drawing");

        let map_bounds = map.getBounds();
        let map_box = {
            "min_lat": map_bounds.getSouth(),
            "min_lng": map_bounds.getWest(),
            "max_lat": map_bounds.getNorth(),
            "max_lng": map_bounds.getEast()
        }
        //console.log("draw_airports", map_box);

        for (let box_id in this.airports_data.box_coords) {
            let box = this.airports_data.box_coords[box_id];
            if (this.DEBUG_DRAW_MAP_BOXES) {
                L.rectangle([
                    [box.min_lat, box.min_lng],
                    [box.max_lat, box.max_lng]
                ]).addTo(map);
            }
            if (Geo.box_overlap(box, map_box)) {
                //console.log("overlap",box_id, box);
                let airports = this.airports_data.boxes[box_id];
                for (let i = 0; i < airports.length; i++) {
                    let airport = airports[i];
                    let type = airport[this.KEY_TYPE];
                    if (type.includes("airport")) {
                        // Skip this airport if it's non-msfs and insufficient zoom
                        if (! type.includes("msfs") && zoom < ZOOM_MIN_OTHER) {
                            continue;
                        }
                        let position = new L.latLng(airport[this.KEY_LAT], airport[this.KEY_LNG]);
                        let runways = airport[this.KEY_RUNWAYS];

                        let marker;
                        if (type == "msfs_airport") {
                            // For MSFS airports we use a "canvasMarker" i.e. place a rotated 20x20 IMAGE on the canvas
                            // Calculate the first runway direction
                            let px = Math.max(14,Math.min(60,10 * (zoom - 7)));

                            let airport_rotate = null;
                            if (runways != null && runways.length > 0) {
                                airport_rotate = parseInt(runways) * 10;
                            }

                            marker = L.canvasMarker(position, {
                                renderer: this.mapper.canvas_renderer,
                                img: {  url: this.AIRPORT_IMG_URL,
                                        rotate: airport_rotate,
                                        size: [px,px]
                                }
                            });
                        } else {
                            // For non-MSFS airports we use a light green circle
                            let circle_radius = 3 * (zoom - 7);
                            if (type == "large_airport") {
                                circle_radius *= 3;
                            } else if (type == "medium_airport") {
                                circle_radius *= 2;
                            }

                            marker = L.circleMarker(position, {
                                renderer: this.mapper.canvas_renderer,
                                color: '#33ff88',
                                radius: circle_radius
                            });
                        }
                        marker.addTo(this.mapper.airport_markers);

                        if (!this.is_instrument()) {
                            let ident = airport[this.KEY_IDENT];
                            //let name = airport[this.KEY_NAME].replaceAll('"', ""); // Remove double quotes if original name includes those.
                            let name = airport[this.KEY_NAME].replace(/"/g, '');
                            let alt_m = airport[this.KEY_ALT_M];
                            // add popup
                            let popup_content = name + "<br/>" + type + "<br/>" + ident;
                            let popup = L.popup({
                                autoPan: false,
                                className: "airport_popup"
                            }).setContent(popup_content);
                            marker.bindPopup(popup);

                            marker.on('mouseover', function(event) {
                                marker.openPopup();
                            });
                            marker.on('mouseout', function(event) {
                                marker.closePopup();
                            });
                            //marker.on('click', (e) => {
                            //    console.log("User click:", ident, name);
                            //    this.mapper.task.add_new_poi(position, type, {
                            //        "ident": ident,
                            //        "name": name,
                            //        "alt_m": alt_m,
                            //        "runways": runways
                            //    });
                            //});
                            if (ident == this.search_ident) {
                                marker.openPopup();
                                this.search_ident = null;
                            }
                        }
                    }
                }
            }
        }
    }

    // Return true if given airport "type" represents an MSFS airport
    is_msfs_airport(type) {
        return type != null && type.includes("msfs") && type.includes("airport")
    }

    // Return true if these airports are being displayed in an MSFS instrument
    is_instrument() {
        return this.instrument != null;
    }

    // Return airport info given ident e.g. lookup("LSMM") returns
    // { alt_m: 579.1, ident: "LSMM", lat: 46.74333, lng: 8.109999, name: "Meiringen Mil", runways: "28 10", type: "msfs_airport" }
    // Note our airports data structure is highly optimised for a lookup by lat/long (i.e. stored by latlong 'boxes')
    // so for what would seem a simple 'lookup by ident' we actually have to search all the airports.
    lookup(ident) {
        if (!this.available) {
            console.log("ERROR: airports lookup request, but data not available", ident);
            return null;
        }
        //console.log("b21_airports lookup", ident);
        for (const [box_key, airports_list] of Object.entries(this.airports_data.boxes)) {
            //console.log(box_key);
            for (let i = 0; i < airports_list.length; i++) {
                // airports_list is a list of the airports in the current 'box'
                // so airports_list[i] is the current airport we're checking for the ident
                // Each airport info is stored as a list of values, as defined in airport_keys
                if (airports_list[i][this.KEY_IDENT] == ident) {
                    //console.log("airports lookup ident found", ident, airports_list[i]);
                    return this.airport_list_to_obj(airports_list[i]);
                }
            }
        }
        console.log("airports.js lookup failed for "+ident);
        return null;
    }

    // Convert the compact airports list data to a JS obj
    airport_list_to_obj(airport_list) {
        let airport_info = {};
        // Note we use 'airport_keys' to map from key name (e.g. ident) to array entry (e.g. 0)
        for (const [key, value] of Object.entries(this.airports_data.airport_keys)) {
            airport_info[key] = airport_list[value]
        }
        airport_info["id"] = airport_info["ident"];
        airport_info["source"] = airport_info["type"] == "msfs_airport" ? "msfs_airports" : "ourairports";
        return airport_info
    }

    // User has typed in search box
    search(search_value) {
        let parent = this;
        const RESULTS_MAX = 50;
        let results = [];
        for (let box_id in this.airports_data.box_coords) {
            let airports = this.airports_data.boxes[box_id];
            for (let i = 0; i < airports.length; i++) {
                let airport = airports[i];
                let type = airport[this.KEY_TYPE];
                if (type.includes("airport")) {
                    let ident = airport[this.KEY_IDENT];
                    let name = airport[this.KEY_NAME].replaceAll('"', ""); // Remove double quotes if original name includes those.
                    if ((ident + "!" + name).toLowerCase().includes(search_value)) {
                        results.push(this.airport_list_to_obj(airport));
                        if (results.length > RESULTS_MAX) {
                            break;
                        }
                    }
                }
            }
            if (results.length > RESULTS_MAX) {
                break;
            }
        }

        return results;
    }

} // end class B21_Airports
